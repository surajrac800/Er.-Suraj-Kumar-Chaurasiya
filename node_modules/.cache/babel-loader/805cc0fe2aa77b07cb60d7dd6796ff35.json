{"ast":null,"code":"import { isNumericalString } from '../../utils/is-numerical-string.mjs';\nimport { isZeroValueString } from '../../utils/is-zero-value-string.mjs';\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\nimport { motionValue } from '../../value/index.mjs';\nimport { complex } from '../../value/types/complex/index.mjs';\nimport { getAnimatableNone } from '../dom/value-types/animatable-none.mjs';\nimport { findValueType } from '../dom/value-types/find.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\n\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\n\nfunction setTarget(visualElement, definition) {\n  const resolved = resolveVariant(visualElement, definition);\n  let {\n    transitionEnd = {},\n    transition = {},\n    ...target\n  } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};\n  target = { ...target,\n    ...transitionEnd\n  };\n\n  for (const key in target) {\n    const value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\n\nfunction setVariants(visualElement, variantLabels) {\n  const reversedLabels = [...variantLabels].reverse();\n  reversedLabels.forEach(key => {\n    const variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n\n    if (visualElement.variantChildren) {\n      visualElement.variantChildren.forEach(child => {\n        setVariants(child, variantLabels);\n      });\n    }\n  });\n}\n\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\n\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b;\n\n  const newValueKeys = Object.keys(target).filter(key => !visualElement.hasValue(key));\n  const numNewValues = newValueKeys.length;\n  if (!numNewValues) return;\n\n  for (let i = 0; i < numNewValues; i++) {\n    const key = newValueKeys[i];\n    const targetValue = target[key];\n    let value = null;\n    /**\n     * If the target is a series of keyframes, we can use the first value\n     * in the array. If this first value is null, we'll still need to read from the DOM.\n     */\n\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    /**\n     * If the target isn't keyframes, or the first keyframe was null, we need to\n     * first check if an origin value was explicitly defined in the transition as \"from\",\n     * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n     */\n\n\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    /**\n     * If value is still undefined or null, ignore it. Preferably this would throw,\n     * but this was causing issues in Framer.\n     */\n\n\n    if (value === undefined || value === null) continue;\n\n    if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n      // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n      value = parseFloat(value);\n    } else if (!findValueType(value) && complex.test(targetValue)) {\n      value = getAnimatableNone(key, targetValue);\n    }\n\n    visualElement.addValue(key, motionValue(value, {\n      owner: visualElement\n    }));\n\n    if (origin[key] === undefined) {\n      origin[key] = value;\n    }\n\n    if (value !== null) visualElement.setBaseTarget(key, value);\n  }\n}\n\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  const valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\n\nfunction getOrigin(target, transition, visualElement) {\n  const origin = {};\n\n  for (const key in target) {\n    const transitionOrigin = getOriginFromTransition(key, transition);\n\n    if (transitionOrigin !== undefined) {\n      origin[key] = transitionOrigin;\n    } else {\n      const value = visualElement.getValue(key);\n\n      if (value) {\n        origin[key] = value.get();\n      }\n    }\n  }\n\n  return origin;\n}\n\nexport { checkTargetForNewValues, getOrigin, getOriginFromTransition, setTarget, setValues };","map":{"version":3,"sources":["C:/Users/91800/Desktop/Personal-Portfolio-React-master/node_modules/framer-motion/dist/es/render/utils/setters.mjs"],"names":["isNumericalString","isZeroValueString","resolveFinalValueInKeyframes","motionValue","complex","getAnimatableNone","findValueType","resolveVariant","setMotionValue","visualElement","key","value","hasValue","getValue","set","addValue","setTarget","definition","resolved","transitionEnd","transition","target","makeTargetAnimatable","setVariants","variantLabels","reversedLabels","reverse","forEach","variant","getVariant","variantChildren","child","setValues","Array","isArray","checkTargetForNewValues","origin","_a","_b","newValueKeys","Object","keys","filter","numNewValues","length","i","targetValue","readValue","undefined","parseFloat","test","owner","setBaseTarget","getOriginFromTransition","valueTransition","from","getOrigin","transitionOrigin","get"],"mappings":"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","sourcesContent":["import { isNumericalString } from '../../utils/is-numerical-string.mjs';\nimport { isZeroValueString } from '../../utils/is-zero-value-string.mjs';\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\nimport { motionValue } from '../../value/index.mjs';\nimport { complex } from '../../value/types/complex/index.mjs';\nimport { getAnimatableNone } from '../dom/value-types/animatable-none.mjs';\nimport { findValueType } from '../dom/value-types/find.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    const resolved = resolveVariant(visualElement, definition);\n    let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};\n    target = { ...target, ...transitionEnd };\n    for (const key in target) {\n        const value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\nfunction setVariants(visualElement, variantLabels) {\n    const reversedLabels = [...variantLabels].reverse();\n    reversedLabels.forEach((key) => {\n        const variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        if (visualElement.variantChildren) {\n            visualElement.variantChildren.forEach((child) => {\n                setVariants(child, variantLabels);\n            });\n        }\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n    var _a, _b;\n    const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));\n    const numNewValues = newValueKeys.length;\n    if (!numNewValues)\n        return;\n    for (let i = 0; i < numNewValues; i++) {\n        const key = newValueKeys[i];\n        const targetValue = target[key];\n        let value = null;\n        /**\n         * If the target is a series of keyframes, we can use the first value\n         * in the array. If this first value is null, we'll still need to read from the DOM.\n         */\n        if (Array.isArray(targetValue)) {\n            value = targetValue[0];\n        }\n        /**\n         * If the target isn't keyframes, or the first keyframe was null, we need to\n         * first check if an origin value was explicitly defined in the transition as \"from\",\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n         */\n        if (value === null) {\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n        }\n        /**\n         * If value is still undefined or null, ignore it. Preferably this would throw,\n         * but this was causing issues in Framer.\n         */\n        if (value === undefined || value === null)\n            continue;\n        if (typeof value === \"string\" &&\n            (isNumericalString(value) || isZeroValueString(value))) {\n            // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n            value = parseFloat(value);\n        }\n        else if (!findValueType(value) && complex.test(targetValue)) {\n            value = getAnimatableNone(key, targetValue);\n        }\n        visualElement.addValue(key, motionValue(value, { owner: visualElement }));\n        if (origin[key] === undefined) {\n            origin[key] = value;\n        }\n        if (value !== null)\n            visualElement.setBaseTarget(key, value);\n    }\n}\nfunction getOriginFromTransition(key, transition) {\n    if (!transition)\n        return;\n    const valueTransition = transition[key] || transition[\"default\"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    const origin = {};\n    for (const key in target) {\n        const transitionOrigin = getOriginFromTransition(key, transition);\n        if (transitionOrigin !== undefined) {\n            origin[key] = transitionOrigin;\n        }\n        else {\n            const value = visualElement.getValue(key);\n            if (value) {\n                origin[key] = value.get();\n            }\n        }\n    }\n    return origin;\n}\n\nexport { checkTargetForNewValues, getOrigin, getOriginFromTransition, setTarget, setValues };\n"]},"metadata":{},"sourceType":"module"}