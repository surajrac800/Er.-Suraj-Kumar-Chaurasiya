{"ast":null,"code":"/* eslint-disable consistent-return */\nimport { getWindow } from 'ssr-window';\nimport { now, nextTick } from '../../shared/utils.js';\nexport default function Mousewheel(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const window = getWindow();\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null,\n      noMousewheelClass: 'swiper-no-mousewheel'\n    }\n  });\n  swiper.mousewheel = {\n    enabled: false\n  };\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n\n  function normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n    // Legacy\n\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    } // side scrolling on FF with DOMMouseScroll\n\n\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    } // Fall-back if spin cannot be determined\n\n\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  }\n\n  function handleMouseEnter() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  }\n\n  function handleMouseLeave() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  }\n\n  function animateSlider(newEvent) {\n    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n\n    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    } // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n\n\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    } // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n\n\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit('scroll', newEvent.raw);\n    } // If you got here is because an animation has been triggered so store the current time\n\n\n    lastScrollTime = new window.Date().getTime(); // Return false as a default\n\n    return false;\n  }\n\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n\n    return false;\n  }\n\n  function handle(event) {\n    let e = event;\n    let disableParentSwiper = true;\n    if (!swiper.enabled) return; // Ignore event if the target or its parents have the swiper-no-mousewheel class\n\n    if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n    const params = swiper.params.mousewheel;\n\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n\n    let targetEl = swiper.el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    const data = normalize(e);\n\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta; // Get the scroll positions\n\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      // Register the new event in a variable which stores the relevant data\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      }; // Keep the most recent events\n\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      } // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n\n\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = undefined;\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n\n        if (swiper.params.loop) {\n          swiper.loopFix({\n            direction: newEvent.direction < 0 ? 'next' : 'prev',\n            byMousewheel: true\n          });\n        }\n\n        if (swiper.params.freeMode.sticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(timeout);\n          timeout = undefined;\n\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            recentWheelEvents.splice(0);\n          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            timeout = nextTick(() => {\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        } // Emit event\n\n\n        if (!ignoreWheelEvents) emit('scroll', e); // Stop autoplay\n\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions\n\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  }\n\n  function events(method) {\n    let targetEl = swiper.el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n\n    targetEl[method]('mouseenter', handleMouseEnter);\n    targetEl[method]('mouseleave', handleMouseLeave);\n    targetEl[method]('wheel', handle);\n  }\n\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener('wheel', handle);\n      return true;\n    }\n\n    if (swiper.mousewheel.enabled) return false;\n    events('addEventListener');\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n\n    if (!swiper.mousewheel.enabled) return false;\n    events('removeEventListener');\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n\n  on('init', () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n\n    if (swiper.params.mousewheel.enabled) enable();\n  });\n  on('destroy', () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n\n    if (swiper.mousewheel.enabled) disable();\n  });\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable\n  });\n}","map":{"version":3,"sources":["C:/Users/91800/Desktop/Personal-Portfolio-React-master/node_modules/swiper/modules/mousewheel/mousewheel.js"],"names":["getWindow","now","nextTick","Mousewheel","swiper","extendParams","on","emit","window","mousewheel","enabled","releaseOnEdges","invert","forceToAxis","sensitivity","eventsTarget","thresholdDelta","thresholdTime","noMousewheelClass","timeout","lastScrollTime","lastEventBeforeSnap","recentWheelEvents","normalize","e","PIXEL_STEP","LINE_HEIGHT","PAGE_HEIGHT","sX","sY","pX","pY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","deltaY","deltaX","shiftKey","deltaMode","spinX","spinY","pixelX","pixelY","handleMouseEnter","mouseEntered","handleMouseLeave","animateSlider","newEvent","params","delta","direction","isEnd","loop","animating","slideNext","raw","isBeginning","slidePrev","Date","getTime","releaseScroll","handle","event","disableParentSwiper","target","closest","cssMode","preventDefault","targetEl","el","document","querySelector","targetElContainsTarget","contains","originalEvent","rtlFactor","rtlTranslate","data","isHorizontal","Math","abs","positions","getTranslate","minTranslate","maxTranslate","nested","stopPropagation","freeMode","time","sign","length","shift","prevEvent","undefined","push","ignoreWheelEvents","position","wasBeginning","wasEnd","setTransition","setTranslate","updateProgress","updateActiveIndex","updateSlidesClasses","loopFix","byMousewheel","sticky","clearTimeout","firstEvent","splice","snapToThreshold","slideToClosest","speed","autoplay","autoplayDisableOnInteraction","stop","returnValue","events","method","enable","wrapperEl","removeEventListener","disable","addEventListener","Object","assign"],"mappings":"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","sourcesContent":["/* eslint-disable consistent-return */\nimport { getWindow } from 'ssr-window';\nimport { now, nextTick } from '../../shared/utils.js';\nexport default function Mousewheel({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const window = getWindow();\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null,\n      noMousewheelClass: 'swiper-no-mousewheel'\n    }\n  });\n  swiper.mousewheel = {\n    enabled: false\n  };\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n  function normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  }\n  function handleMouseEnter() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  }\n  function handleMouseLeave() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  }\n  function animateSlider(newEvent) {\n    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    }\n\n    // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    }\n    // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit('scroll', newEvent.raw);\n    }\n    // If you got here is because an animation has been triggered so store the current time\n    lastScrollTime = new window.Date().getTime();\n    // Return false as a default\n    return false;\n  }\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n    return false;\n  }\n  function handle(event) {\n    let e = event;\n    let disableParentSwiper = true;\n    if (!swiper.enabled) return;\n\n    // Ignore event if the target or its parents have the swiper-no-mousewheel class\n    if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n    const params = swiper.params.mousewheel;\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    const data = normalize(e);\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta;\n\n    // Get the scroll positions\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n    // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      // Register the new event in a variable which stores the relevant data\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      };\n\n      // Keep the most recent events\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent);\n\n      // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      }\n\n      // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = undefined;\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n        if (swiper.params.loop) {\n          swiper.loopFix({\n            direction: newEvent.direction < 0 ? 'next' : 'prev',\n            byMousewheel: true\n          });\n        }\n        if (swiper.params.freeMode.sticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(timeout);\n          timeout = undefined;\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            recentWheelEvents.splice(0);\n          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            timeout = nextTick(() => {\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        }\n\n        // Emit event\n        if (!ignoreWheelEvents) emit('scroll', e);\n\n        // Stop autoplay\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n        // Return page scroll on edge positions\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  }\n  function events(method) {\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    targetEl[method]('mouseenter', handleMouseEnter);\n    targetEl[method]('mouseleave', handleMouseLeave);\n    targetEl[method]('wheel', handle);\n  }\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener('wheel', handle);\n      return true;\n    }\n    if (swiper.mousewheel.enabled) return false;\n    events('addEventListener');\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n    if (!swiper.mousewheel.enabled) return false;\n    events('removeEventListener');\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n  on('init', () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n    if (swiper.params.mousewheel.enabled) enable();\n  });\n  on('destroy', () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n    if (swiper.mousewheel.enabled) disable();\n  });\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable\n  });\n}"]},"metadata":{},"sourceType":"module"}