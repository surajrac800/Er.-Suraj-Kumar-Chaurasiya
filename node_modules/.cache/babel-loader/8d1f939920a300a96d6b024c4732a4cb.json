{"ast":null,"code":"import { transformProps } from '../../render/html/utils/transform.mjs';\nimport { millisecondsToSeconds } from '../../utils/time-conversion.mjs';\nimport { appearAnimationStore } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\n\nfunction handoffOptimizedAppearAnimation(id, name, value,\n/**\n * This function is loaded via window by startOptimisedAnimation.\n * By accepting `sync` as an argument, rather than using it via\n * import, it can be kept out of the first-load Framer bundle,\n * while also allowing this function to not be included in\n * Framer Motion bundles where it's not needed.\n */\nframe) {\n  const storeId = appearStoreId(id, transformProps.has(name) ? \"transform\" : name);\n  const appearAnimation = appearAnimationStore.get(storeId);\n  if (!appearAnimation) return 0;\n  const {\n    animation,\n    startTime\n  } = appearAnimation;\n\n  const cancelOptimisedAnimation = () => {\n    appearAnimationStore.delete(storeId);\n    /**\n     * Animation.cancel() throws so it needs to be wrapped in a try/catch\n     */\n\n    try {\n      animation.cancel();\n    } catch (e) {}\n  };\n\n  if (startTime !== null) {\n    const sampledTime = performance.now();\n    /**\n     * Resync handoff animation with optimised animation.\n     *\n     * This step would be unnecessary if we triggered animateChanges() in useEffect,\n     * but due to potential hydration errors we currently fire them in useLayoutEffect.\n     *\n     * By the time we're safely ready to cancel the optimised WAAPI animation,\n     * the main thread might have been blocked and desynced the two animations.\n     *\n     * Here, we resync the two animations before the optimised WAAPI animation is cancelled.\n     */\n\n    frame.update(() => {\n      if (value.animation) {\n        value.animation.time = millisecondsToSeconds(performance.now() - sampledTime);\n      }\n    });\n    /**\n     * We allow the animation to persist until the next frame:\n     *   1. So it continues to play until Framer Motion is ready to render\n     *      (avoiding a potential flash of the element's original state)\n     *   2. As all independent transforms share a single transform animation, stopping\n     *      it synchronously would prevent subsequent transforms from handing off.\n     */\n\n    frame.render(cancelOptimisedAnimation);\n    /**\n     * We use main thread timings vs those returned by Animation.currentTime as it\n     * can be the case, particularly in Firefox, that currentTime doesn't return\n     * an updated value for several frames, even as the animation plays smoothly via\n     * the GPU.\n     */\n\n    return sampledTime - startTime || 0;\n  } else {\n    cancelOptimisedAnimation();\n    return 0;\n  }\n}\n\nexport { handoffOptimizedAppearAnimation };","map":{"version":3,"sources":["C:/Users/91800/Desktop/Personal-Portfolio-React-master/node_modules/framer-motion/dist/es/animation/optimized-appear/handoff.mjs"],"names":["transformProps","millisecondsToSeconds","appearAnimationStore","appearStoreId","handoffOptimizedAppearAnimation","id","name","value","frame","storeId","has","appearAnimation","get","animation","startTime","cancelOptimisedAnimation","delete","cancel","e","sampledTime","performance","now","update","time","render"],"mappings":"AAAA,SAASA,cAAT,QAA+B,uCAA/B;AACA,SAASC,qBAAT,QAAsC,iCAAtC;AACA,SAASC,oBAAT,QAAqC,aAArC;AACA,SAASC,aAAT,QAA8B,gBAA9B;;AAEA,SAASC,+BAAT,CAAyCC,EAAzC,EAA6CC,IAA7C,EAAmDC,KAAnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,KARA,EAQO;AACH,QAAMC,OAAO,GAAGN,aAAa,CAACE,EAAD,EAAKL,cAAc,CAACU,GAAf,CAAmBJ,IAAnB,IAA2B,WAA3B,GAAyCA,IAA9C,CAA7B;AACA,QAAMK,eAAe,GAAGT,oBAAoB,CAACU,GAArB,CAAyBH,OAAzB,CAAxB;AACA,MAAI,CAACE,eAAL,EACI,OAAO,CAAP;AACJ,QAAM;AAAEE,IAAAA,SAAF;AAAaC,IAAAA;AAAb,MAA2BH,eAAjC;;AACA,QAAMI,wBAAwB,GAAG,MAAM;AACnCb,IAAAA,oBAAoB,CAACc,MAArB,CAA4BP,OAA5B;AACA;AACR;AACA;;AACQ,QAAI;AACAI,MAAAA,SAAS,CAACI,MAAV;AACH,KAFD,CAGA,OAAOC,CAAP,EAAU,CAAG;AAChB,GATD;;AAUA,MAAIJ,SAAS,KAAK,IAAlB,EAAwB;AACpB,UAAMK,WAAW,GAAGC,WAAW,CAACC,GAAZ,EAApB;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACQb,IAAAA,KAAK,CAACc,MAAN,CAAa,MAAM;AACf,UAAIf,KAAK,CAACM,SAAV,EAAqB;AACjBN,QAAAA,KAAK,CAACM,SAAN,CAAgBU,IAAhB,GAAuBtB,qBAAqB,CAACmB,WAAW,CAACC,GAAZ,KAAoBF,WAArB,CAA5C;AACH;AACJ,KAJD;AAKA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQX,IAAAA,KAAK,CAACgB,MAAN,CAAaT,wBAAb;AACA;AACR;AACA;AACA;AACA;AACA;;AACQ,WAAOI,WAAW,GAAGL,SAAd,IAA2B,CAAlC;AACH,GAjCD,MAkCK;AACDC,IAAAA,wBAAwB;AACxB,WAAO,CAAP;AACH;AACJ;;AAED,SAASX,+BAAT","sourcesContent":["import { transformProps } from '../../render/html/utils/transform.mjs';\nimport { millisecondsToSeconds } from '../../utils/time-conversion.mjs';\nimport { appearAnimationStore } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\n\nfunction handoffOptimizedAppearAnimation(id, name, value, \n/**\n * This function is loaded via window by startOptimisedAnimation.\n * By accepting `sync` as an argument, rather than using it via\n * import, it can be kept out of the first-load Framer bundle,\n * while also allowing this function to not be included in\n * Framer Motion bundles where it's not needed.\n */\nframe) {\n    const storeId = appearStoreId(id, transformProps.has(name) ? \"transform\" : name);\n    const appearAnimation = appearAnimationStore.get(storeId);\n    if (!appearAnimation)\n        return 0;\n    const { animation, startTime } = appearAnimation;\n    const cancelOptimisedAnimation = () => {\n        appearAnimationStore.delete(storeId);\n        /**\n         * Animation.cancel() throws so it needs to be wrapped in a try/catch\n         */\n        try {\n            animation.cancel();\n        }\n        catch (e) { }\n    };\n    if (startTime !== null) {\n        const sampledTime = performance.now();\n        /**\n         * Resync handoff animation with optimised animation.\n         *\n         * This step would be unnecessary if we triggered animateChanges() in useEffect,\n         * but due to potential hydration errors we currently fire them in useLayoutEffect.\n         *\n         * By the time we're safely ready to cancel the optimised WAAPI animation,\n         * the main thread might have been blocked and desynced the two animations.\n         *\n         * Here, we resync the two animations before the optimised WAAPI animation is cancelled.\n         */\n        frame.update(() => {\n            if (value.animation) {\n                value.animation.time = millisecondsToSeconds(performance.now() - sampledTime);\n            }\n        });\n        /**\n         * We allow the animation to persist until the next frame:\n         *   1. So it continues to play until Framer Motion is ready to render\n         *      (avoiding a potential flash of the element's original state)\n         *   2. As all independent transforms share a single transform animation, stopping\n         *      it synchronously would prevent subsequent transforms from handing off.\n         */\n        frame.render(cancelOptimisedAnimation);\n        /**\n         * We use main thread timings vs those returned by Animation.currentTime as it\n         * can be the case, particularly in Firefox, that currentTime doesn't return\n         * an updated value for several frames, even as the animation plays smoothly via\n         * the GPU.\n         */\n        return sampledTime - startTime || 0;\n    }\n    else {\n        cancelOptimisedAnimation();\n        return 0;\n    }\n}\n\nexport { handoffOptimizedAppearAnimation };\n"]},"metadata":{},"sourceType":"module"}