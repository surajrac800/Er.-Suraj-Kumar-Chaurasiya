{"ast":null,"code":"function buildProjectionTransform(delta, treeScale, latestTransform) {\n  let transform = \"\";\n  /**\n   * The translations we use to calculate are always relative to the viewport coordinate space.\n   * But when we apply scales, we also scale the coordinate space of an element and its children.\n   * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n   * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n   */\n\n  const xTranslate = delta.x.translate / treeScale.x;\n  const yTranslate = delta.y.translate / treeScale.y;\n\n  if (xTranslate || yTranslate) {\n    transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;\n  }\n  /**\n   * Apply scale correction for the tree transform.\n   * This will apply scale to the screen-orientated axes.\n   */\n\n\n  if (treeScale.x !== 1 || treeScale.y !== 1) {\n    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n  }\n\n  if (latestTransform) {\n    const {\n      rotate,\n      rotateX,\n      rotateY\n    } = latestTransform;\n    if (rotate) transform += `rotate(${rotate}deg) `;\n    if (rotateX) transform += `rotateX(${rotateX}deg) `;\n    if (rotateY) transform += `rotateY(${rotateY}deg) `;\n  }\n  /**\n   * Apply scale to match the size of the element to the size we want it.\n   * This will apply scale to the element-orientated axes.\n   */\n\n\n  const elementScaleX = delta.x.scale * treeScale.x;\n  const elementScaleY = delta.y.scale * treeScale.y;\n\n  if (elementScaleX !== 1 || elementScaleY !== 1) {\n    transform += `scale(${elementScaleX}, ${elementScaleY})`;\n  }\n\n  return transform || \"none\";\n}\n\nexport { buildProjectionTransform };","map":{"version":3,"sources":["C:/Users/91800/Desktop/Personal-Portfolio-React-master/node_modules/framer-motion/dist/es/projection/styles/transform.mjs"],"names":["buildProjectionTransform","delta","treeScale","latestTransform","transform","xTranslate","x","translate","yTranslate","y","rotate","rotateX","rotateY","elementScaleX","scale","elementScaleY"],"mappings":"AAAA,SAASA,wBAAT,CAAkCC,KAAlC,EAAyCC,SAAzC,EAAoDC,eAApD,EAAqE;AACjE,MAAIC,SAAS,GAAG,EAAhB;AACA;AACJ;AACA;AACA;AACA;AACA;;AACI,QAAMC,UAAU,GAAGJ,KAAK,CAACK,CAAN,CAAQC,SAAR,GAAoBL,SAAS,CAACI,CAAjD;AACA,QAAME,UAAU,GAAGP,KAAK,CAACQ,CAAN,CAAQF,SAAR,GAAoBL,SAAS,CAACO,CAAjD;;AACA,MAAIJ,UAAU,IAAIG,UAAlB,EAA8B;AAC1BJ,IAAAA,SAAS,GAAI,eAAcC,UAAW,OAAMG,UAAW,SAAvD;AACH;AACD;AACJ;AACA;AACA;;;AACI,MAAIN,SAAS,CAACI,CAAV,KAAgB,CAAhB,IAAqBJ,SAAS,CAACO,CAAV,KAAgB,CAAzC,EAA4C;AACxCL,IAAAA,SAAS,IAAK,SAAQ,IAAIF,SAAS,CAACI,CAAE,KAAI,IAAIJ,SAAS,CAACO,CAAE,IAA1D;AACH;;AACD,MAAIN,eAAJ,EAAqB;AACjB,UAAM;AAAEO,MAAAA,MAAF;AAAUC,MAAAA,OAAV;AAAmBC,MAAAA;AAAnB,QAA+BT,eAArC;AACA,QAAIO,MAAJ,EACIN,SAAS,IAAK,UAASM,MAAO,OAA9B;AACJ,QAAIC,OAAJ,EACIP,SAAS,IAAK,WAAUO,OAAQ,OAAhC;AACJ,QAAIC,OAAJ,EACIR,SAAS,IAAK,WAAUQ,OAAQ,OAAhC;AACP;AACD;AACJ;AACA;AACA;;;AACI,QAAMC,aAAa,GAAGZ,KAAK,CAACK,CAAN,CAAQQ,KAAR,GAAgBZ,SAAS,CAACI,CAAhD;AACA,QAAMS,aAAa,GAAGd,KAAK,CAACQ,CAAN,CAAQK,KAAR,GAAgBZ,SAAS,CAACO,CAAhD;;AACA,MAAII,aAAa,KAAK,CAAlB,IAAuBE,aAAa,KAAK,CAA7C,EAAgD;AAC5CX,IAAAA,SAAS,IAAK,SAAQS,aAAc,KAAIE,aAAc,GAAtD;AACH;;AACD,SAAOX,SAAS,IAAI,MAApB;AACH;;AAED,SAASJ,wBAAT","sourcesContent":["function buildProjectionTransform(delta, treeScale, latestTransform) {\n    let transform = \"\";\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    const xTranslate = delta.x.translate / treeScale.x;\n    const yTranslate = delta.y.translate / treeScale.y;\n    if (xTranslate || yTranslate) {\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;\n    }\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n    }\n    if (latestTransform) {\n        const { rotate, rotateX, rotateY } = latestTransform;\n        if (rotate)\n            transform += `rotate(${rotate}deg) `;\n        if (rotateX)\n            transform += `rotateX(${rotateX}deg) `;\n        if (rotateY)\n            transform += `rotateY(${rotateY}deg) `;\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    const elementScaleX = delta.x.scale * treeScale.x;\n    const elementScaleY = delta.y.scale * treeScale.y;\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\n    }\n    return transform || \"none\";\n}\n\nexport { buildProjectionTransform };\n"]},"metadata":{},"sourceType":"module"}