{"ast":null,"code":"import { cssVariableRegex } from '../../../render/dom/utils/is-css-variable.mjs';\nimport { noop } from '../../../utils/noop.mjs';\nimport { color } from '../color/index.mjs';\nimport { number } from '../numbers/index.mjs';\nimport { colorRegex, floatRegex, isString, sanitize } from '../utils.mjs';\n\nfunction test(v) {\n  var _a, _b;\n\n  return isNaN(v) && isString(v) && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;\n}\n\nconst cssVarTokeniser = {\n  regex: cssVariableRegex,\n  countKey: \"Vars\",\n  token: \"${v}\",\n  parse: noop\n};\nconst colorTokeniser = {\n  regex: colorRegex,\n  countKey: \"Colors\",\n  token: \"${c}\",\n  parse: color.parse\n};\nconst numberTokeniser = {\n  regex: floatRegex,\n  countKey: \"Numbers\",\n  token: \"${n}\",\n  parse: number.parse\n};\n\nfunction tokenise(info, _ref) {\n  let {\n    regex,\n    countKey,\n    token,\n    parse\n  } = _ref;\n  const matches = info.tokenised.match(regex);\n  if (!matches) return;\n  info[\"num\" + countKey] = matches.length;\n  info.tokenised = info.tokenised.replace(regex, token);\n  info.values.push(...matches.map(parse));\n}\n\nfunction analyseComplexValue(value) {\n  const originalValue = value.toString();\n  const info = {\n    value: originalValue,\n    tokenised: originalValue,\n    values: [],\n    numVars: 0,\n    numColors: 0,\n    numNumbers: 0\n  };\n  if (info.value.includes(\"var(--\")) tokenise(info, cssVarTokeniser);\n  tokenise(info, colorTokeniser);\n  tokenise(info, numberTokeniser);\n  return info;\n}\n\nfunction parseComplexValue(v) {\n  return analyseComplexValue(v).values;\n}\n\nfunction createTransformer(source) {\n  const {\n    values,\n    numColors,\n    numVars,\n    tokenised\n  } = analyseComplexValue(source);\n  const numValues = values.length;\n  return v => {\n    let output = tokenised;\n\n    for (let i = 0; i < numValues; i++) {\n      if (i < numVars) {\n        output = output.replace(cssVarTokeniser.token, v[i]);\n      } else if (i < numVars + numColors) {\n        output = output.replace(colorTokeniser.token, color.transform(v[i]));\n      } else {\n        output = output.replace(numberTokeniser.token, sanitize(v[i]));\n      }\n    }\n\n    return output;\n  };\n}\n\nconst convertNumbersToZero = v => typeof v === \"number\" ? 0 : v;\n\nfunction getAnimatableNone(v) {\n  const parsed = parseComplexValue(v);\n  const transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\n\nconst complex = {\n  test,\n  parse: parseComplexValue,\n  createTransformer,\n  getAnimatableNone\n};\nexport { analyseComplexValue, complex };","map":{"version":3,"sources":["C:/Users/91800/Desktop/Personal-Portfolio-React-master/node_modules/framer-motion/dist/es/value/types/complex/index.mjs"],"names":["cssVariableRegex","noop","color","number","colorRegex","floatRegex","isString","sanitize","test","v","_a","_b","isNaN","match","length","cssVarTokeniser","regex","countKey","token","parse","colorTokeniser","numberTokeniser","tokenise","info","matches","tokenised","replace","values","push","map","analyseComplexValue","value","originalValue","toString","numVars","numColors","numNumbers","includes","parseComplexValue","createTransformer","source","numValues","output","i","transform","convertNumbersToZero","getAnimatableNone","parsed","transformer","complex"],"mappings":"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","sourcesContent":["import { cssVariableRegex } from '../../../render/dom/utils/is-css-variable.mjs';\nimport { noop } from '../../../utils/noop.mjs';\nimport { color } from '../color/index.mjs';\nimport { number } from '../numbers/index.mjs';\nimport { colorRegex, floatRegex, isString, sanitize } from '../utils.mjs';\n\nfunction test(v) {\n    var _a, _b;\n    return (isNaN(v) &&\n        isString(v) &&\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\n            0);\n}\nconst cssVarTokeniser = {\n    regex: cssVariableRegex,\n    countKey: \"Vars\",\n    token: \"${v}\",\n    parse: noop,\n};\nconst colorTokeniser = {\n    regex: colorRegex,\n    countKey: \"Colors\",\n    token: \"${c}\",\n    parse: color.parse,\n};\nconst numberTokeniser = {\n    regex: floatRegex,\n    countKey: \"Numbers\",\n    token: \"${n}\",\n    parse: number.parse,\n};\nfunction tokenise(info, { regex, countKey, token, parse }) {\n    const matches = info.tokenised.match(regex);\n    if (!matches)\n        return;\n    info[\"num\" + countKey] = matches.length;\n    info.tokenised = info.tokenised.replace(regex, token);\n    info.values.push(...matches.map(parse));\n}\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const info = {\n        value: originalValue,\n        tokenised: originalValue,\n        values: [],\n        numVars: 0,\n        numColors: 0,\n        numNumbers: 0,\n    };\n    if (info.value.includes(\"var(--\"))\n        tokenise(info, cssVarTokeniser);\n    tokenise(info, colorTokeniser);\n    tokenise(info, numberTokeniser);\n    return info;\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { values, numColors, numVars, tokenised } = analyseComplexValue(source);\n    const numValues = values.length;\n    return (v) => {\n        let output = tokenised;\n        for (let i = 0; i < numValues; i++) {\n            if (i < numVars) {\n                output = output.replace(cssVarTokeniser.token, v[i]);\n            }\n            else if (i < numVars + numColors) {\n                output = output.replace(colorTokeniser.token, color.transform(v[i]));\n            }\n            else {\n                output = output.replace(numberTokeniser.token, sanitize(v[i]));\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone,\n};\n\nexport { analyseComplexValue, complex };\n"]},"metadata":{},"sourceType":"module"}