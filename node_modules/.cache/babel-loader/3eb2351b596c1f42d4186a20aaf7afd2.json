{"ast":null,"code":"import { invariant } from './errors.mjs';\nimport { color } from '../value/types/color/index.mjs';\nimport { clamp } from './clamp.mjs';\nimport { mix } from './mix.mjs';\nimport { mixColor } from './mix-color.mjs';\nimport { mixComplex, mixArray, mixObject } from './mix-complex.mjs';\nimport { pipe } from './pipe.mjs';\nimport { progress } from './progress.mjs';\nimport { noop } from './noop.mjs';\n\nconst mixNumber = (from, to) => p => mix(from, to, p);\n\nfunction detectMixerFactory(v) {\n  if (typeof v === \"number\") {\n    return mixNumber;\n  } else if (typeof v === \"string\") {\n    return color.test(v) ? mixColor : mixComplex;\n  } else if (Array.isArray(v)) {\n    return mixArray;\n  } else if (typeof v === \"object\") {\n    return mixObject;\n  }\n\n  return mixNumber;\n}\n\nfunction createMixers(output, ease, customMixer) {\n  const mixers = [];\n  const mixerFactory = customMixer || detectMixerFactory(output[0]);\n  const numMixers = output.length - 1;\n\n  for (let i = 0; i < numMixers; i++) {\n    let mixer = mixerFactory(output[i], output[i + 1]);\n\n    if (ease) {\n      const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n\n    mixers.push(mixer);\n  }\n\n  return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revist this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\n\n\nfunction interpolate(input, output) {\n  let {\n    clamp: isClamp = true,\n    ease,\n    mixer\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const inputLength = input.length;\n  invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n  /**\n   * If we're only provided a single input, we can just make a function\n   * that returns the output.\n   */\n\n  if (inputLength === 1) return () => output[0]; // If input runs highest -> lowest, reverse both arrays\n\n  if (input[0] > input[inputLength - 1]) {\n    input = [...input].reverse();\n    output = [...output].reverse();\n  }\n\n  const mixers = createMixers(output, ease, mixer);\n  const numMixers = mixers.length;\n\n  const interpolator = v => {\n    let i = 0;\n\n    if (numMixers > 1) {\n      for (; i < input.length - 2; i++) {\n        if (v < input[i + 1]) break;\n      }\n    }\n\n    const progressInRange = progress(input[i], input[i + 1], v);\n    return mixers[i](progressInRange);\n  };\n\n  return isClamp ? v => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;\n}\n\nexport { interpolate };","map":{"version":3,"sources":["C:/Users/91800/Desktop/Personal-Portfolio-React-master/node_modules/framer-motion/dist/es/utils/interpolate.mjs"],"names":["invariant","color","clamp","mix","mixColor","mixComplex","mixArray","mixObject","pipe","progress","noop","mixNumber","from","to","p","detectMixerFactory","v","test","Array","isArray","createMixers","output","ease","customMixer","mixers","mixerFactory","numMixers","length","i","mixer","easingFunction","push","interpolate","input","isClamp","inputLength","reverse","interpolator","progressInRange"],"mappings":"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","sourcesContent":["import { invariant } from './errors.mjs';\nimport { color } from '../value/types/color/index.mjs';\nimport { clamp } from './clamp.mjs';\nimport { mix } from './mix.mjs';\nimport { mixColor } from './mix-color.mjs';\nimport { mixComplex, mixArray, mixObject } from './mix-complex.mjs';\nimport { pipe } from './pipe.mjs';\nimport { progress } from './progress.mjs';\nimport { noop } from './noop.mjs';\n\nconst mixNumber = (from, to) => (p) => mix(from, to, p);\nfunction detectMixerFactory(v) {\n    if (typeof v === \"number\") {\n        return mixNumber;\n    }\n    else if (typeof v === \"string\") {\n        return color.test(v) ? mixColor : mixComplex;\n    }\n    else if (Array.isArray(v)) {\n        return mixArray;\n    }\n    else if (typeof v === \"object\") {\n        return mixObject;\n    }\n    return mixNumber;\n}\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || detectMixerFactory(output[0]);\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revist this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1)\n        return () => output[0];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse();\n        output = [...output].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v) => {\n        let i = 0;\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1])\n                    break;\n            }\n        }\n        const progressInRange = progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nexport { interpolate };\n"]},"metadata":{},"sourceType":"module"}