{"ast":null,"code":"import { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.mjs';\nimport { invariant } from '../../../utils/errors.mjs';\nimport { transformPropOrder } from '../../html/utils/transform.mjs';\nimport { findDimensionValueType } from '../value-types/dimensions.mjs';\nimport { isBrowser } from '../../../utils/is-browser.mjs';\nimport { number } from '../../../value/types/numbers/index.mjs';\nimport { px } from '../../../value/types/numbers/units.mjs';\nconst positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\", \"translateX\", \"translateY\"]);\n\nconst isPositionalKey = key => positionalKeys.has(key);\n\nconst hasPositionalKey = target => {\n  return Object.keys(target).some(isPositionalKey);\n};\n\nconst isNumOrPxType = v => v === number || v === px;\n\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\n\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, _ref) => {\n  let {\n    transform\n  } = _ref;\n  if (transform === \"none\" || !transform) return 0;\n  const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n\n  if (matrix3d) {\n    return getPosFromMatrix(matrix3d[1], pos3);\n  } else {\n    const matrix = transform.match(/^matrix\\((.+)\\)$/);\n\n    if (matrix) {\n      return getPosFromMatrix(matrix[1], pos2);\n    } else {\n      return 0;\n    }\n  }\n};\n\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter(key => !transformKeys.has(key));\n\nfunction removeNonTranslationalTransform(visualElement) {\n  const removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(key => {\n    const value = visualElement.getValue(key);\n\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  }); // Apply changes to element before measurement\n\n  if (removedTransforms.length) visualElement.render();\n  return removedTransforms;\n}\n\nconst positionalValues = {\n  // Dimensions\n  width: (_ref2, _ref3) => {\n    let {\n      x\n    } = _ref2;\n    let {\n      paddingLeft = \"0\",\n      paddingRight = \"0\"\n    } = _ref3;\n    return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);\n  },\n  height: (_ref4, _ref5) => {\n    let {\n      y\n    } = _ref4;\n    let {\n      paddingTop = \"0\",\n      paddingBottom = \"0\"\n    } = _ref5;\n    return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);\n  },\n  top: (_bbox, _ref6) => {\n    let {\n      top\n    } = _ref6;\n    return parseFloat(top);\n  },\n  left: (_bbox, _ref7) => {\n    let {\n      left\n    } = _ref7;\n    return parseFloat(left);\n  },\n  bottom: (_ref8, _ref9) => {\n    let {\n      y\n    } = _ref8;\n    let {\n      top\n    } = _ref9;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: (_ref10, _ref11) => {\n    let {\n      x\n    } = _ref10;\n    let {\n      left\n    } = _ref11;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\n\nconst convertChangedValueTypes = (target, visualElement, changedKeys) => {\n  const originBbox = visualElement.measureViewportBox();\n  const element = visualElement.current;\n  const elementComputedStyle = getComputedStyle(element);\n  const {\n    display\n  } = elementComputedStyle;\n  const origin = {}; // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  }\n  /**\n   * Record origins before we render and update styles\n   */\n\n\n  changedKeys.forEach(key => {\n    origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n  }); // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n\n  visualElement.render();\n  const targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach(key => {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    const value = visualElement.getValue(key);\n    value && value.jump(origin[key]);\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\n\nconst checkAndConvertChangedValueTypes = function (visualElement, target) {\n  let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let transitionEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  target = { ...target\n  };\n  transitionEnd = { ...transitionEnd\n  };\n  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey); // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n\n  let removedTransformValues = [];\n  let hasAttemptedToRemoveTransformValues = false;\n  const changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(key => {\n    const value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    let from = origin[key];\n    let fromType = findDimensionValueType(from);\n    const to = target[key];\n    let toType; // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n\n    if (isKeyframesTarget(to)) {\n      const numKeyframes = to.length;\n      const fromIndex = to[0] === null ? 1 : 0;\n      from = to[fromIndex];\n      fromType = findDimensionValueType(from);\n\n      for (let i = fromIndex; i < numKeyframes; i++) {\n        /**\n         * Don't allow wildcard keyframes to be used to detect\n         * a difference in value types.\n         */\n        if (to[i] === null) break;\n\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        const current = value.get();\n\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        // If one or the other value is 0, it's safe to coerce it to the\n        // type of the other without measurement\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        value.jump(to);\n      }\n    }\n  });\n\n  if (changedValueTypeKeys.length) {\n    const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0 ? window.pageYOffset : null;\n    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys); // If we removed transform values, reapply them before the next render\n\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(_ref12 => {\n        let [key, value] = _ref12;\n        visualElement.getValue(key).set(value);\n      });\n    } // Reapply original values\n\n\n    visualElement.render(); // Restore scroll position\n\n    if (isBrowser && scrollY !== null) {\n      window.scrollTo({\n        top: scrollY\n      });\n    }\n\n    return {\n      target: convertedTarget,\n      transitionEnd\n    };\n  } else {\n    return {\n      target,\n      transitionEnd\n    };\n  }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\n\n\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target,\n    transitionEnd\n  };\n}\n\nexport { positionalValues, unitConversion };","map":{"version":3,"sources":["C:/Users/91800/Desktop/Personal-Portfolio-React-master/node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs"],"names":["isKeyframesTarget","invariant","transformPropOrder","findDimensionValueType","isBrowser","number","px","positionalKeys","Set","isPositionalKey","key","has","hasPositionalKey","target","Object","keys","some","isNumOrPxType","v","getPosFromMatrix","matrix","pos","parseFloat","split","getTranslateFromMatrix","pos2","pos3","_bbox","transform","matrix3d","match","transformKeys","nonTranslationalTransformKeys","filter","removeNonTranslationalTransform","visualElement","removedTransforms","forEach","value","getValue","undefined","push","get","set","startsWith","length","render","positionalValues","width","x","paddingLeft","paddingRight","max","min","height","y","paddingTop","paddingBottom","top","left","bottom","right","convertChangedValueTypes","changedKeys","originBbox","measureViewportBox","element","current","elementComputedStyle","getComputedStyle","display","origin","setStaticValue","targetBbox","jump","checkAndConvertChangedValueTypes","transitionEnd","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","hasValue","from","fromType","to","toType","numKeyframes","fromIndex","i","Array","isArray","map","scrollY","indexOf","window","pageYOffset","convertedTarget","scrollTo","unitConversion"],"mappings":"AAAA,SAASA,iBAAT,QAAkC,kDAAlC;AACA,SAASC,SAAT,QAA0B,2BAA1B;AACA,SAASC,kBAAT,QAAmC,gCAAnC;AACA,SAASC,sBAAT,QAAuC,+BAAvC;AACA,SAASC,SAAT,QAA0B,+BAA1B;AACA,SAASC,MAAT,QAAuB,wCAAvB;AACA,SAASC,EAAT,QAAmB,wCAAnB;AAEA,MAAMC,cAAc,GAAG,IAAIC,GAAJ,CAAQ,CAC3B,OAD2B,EAE3B,QAF2B,EAG3B,KAH2B,EAI3B,MAJ2B,EAK3B,OAL2B,EAM3B,QAN2B,EAO3B,GAP2B,EAQ3B,GAR2B,EAS3B,YAT2B,EAU3B,YAV2B,CAAR,CAAvB;;AAYA,MAAMC,eAAe,GAAIC,GAAD,IAASH,cAAc,CAACI,GAAf,CAAmBD,GAAnB,CAAjC;;AACA,MAAME,gBAAgB,GAAIC,MAAD,IAAY;AACjC,SAAOC,MAAM,CAACC,IAAP,CAAYF,MAAZ,EAAoBG,IAApB,CAAyBP,eAAzB,CAAP;AACH,CAFD;;AAGA,MAAMQ,aAAa,GAAIC,CAAD,IAAOA,CAAC,KAAKb,MAAN,IAAgBa,CAAC,KAAKZ,EAAnD;;AACA,MAAMa,gBAAgB,GAAG,CAACC,MAAD,EAASC,GAAT,KAAiBC,UAAU,CAACF,MAAM,CAACG,KAAP,CAAa,IAAb,EAAmBF,GAAnB,CAAD,CAApD;;AACA,MAAMG,sBAAsB,GAAG,CAACC,IAAD,EAAOC,IAAP,KAAgB,CAACC,KAAD,WAA0B;AAAA,MAAlB;AAAEC,IAAAA;AAAF,GAAkB;AACrE,MAAIA,SAAS,KAAK,MAAd,IAAwB,CAACA,SAA7B,EACI,OAAO,CAAP;AACJ,QAAMC,QAAQ,GAAGD,SAAS,CAACE,KAAV,CAAgB,oBAAhB,CAAjB;;AACA,MAAID,QAAJ,EAAc;AACV,WAAOV,gBAAgB,CAACU,QAAQ,CAAC,CAAD,CAAT,EAAcH,IAAd,CAAvB;AACH,GAFD,MAGK;AACD,UAAMN,MAAM,GAAGQ,SAAS,CAACE,KAAV,CAAgB,kBAAhB,CAAf;;AACA,QAAIV,MAAJ,EAAY;AACR,aAAOD,gBAAgB,CAACC,MAAM,CAAC,CAAD,CAAP,EAAYK,IAAZ,CAAvB;AACH,KAFD,MAGK;AACD,aAAO,CAAP;AACH;AACJ;AACJ,CAhBD;;AAiBA,MAAMM,aAAa,GAAG,IAAIvB,GAAJ,CAAQ,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAR,CAAtB;AACA,MAAMwB,6BAA6B,GAAG9B,kBAAkB,CAAC+B,MAAnB,CAA2BvB,GAAD,IAAS,CAACqB,aAAa,CAACpB,GAAd,CAAkBD,GAAlB,CAApC,CAAtC;;AACA,SAASwB,+BAAT,CAAyCC,aAAzC,EAAwD;AACpD,QAAMC,iBAAiB,GAAG,EAA1B;AACAJ,EAAAA,6BAA6B,CAACK,OAA9B,CAAuC3B,GAAD,IAAS;AAC3C,UAAM4B,KAAK,GAAGH,aAAa,CAACI,QAAd,CAAuB7B,GAAvB,CAAd;;AACA,QAAI4B,KAAK,KAAKE,SAAd,EAAyB;AACrBJ,MAAAA,iBAAiB,CAACK,IAAlB,CAAuB,CAAC/B,GAAD,EAAM4B,KAAK,CAACI,GAAN,EAAN,CAAvB;AACAJ,MAAAA,KAAK,CAACK,GAAN,CAAUjC,GAAG,CAACkC,UAAJ,CAAe,OAAf,IAA0B,CAA1B,GAA8B,CAAxC;AACH;AACJ,GAND,EAFoD,CASpD;;AACA,MAAIR,iBAAiB,CAACS,MAAtB,EACIV,aAAa,CAACW,MAAd;AACJ,SAAOV,iBAAP;AACH;;AACD,MAAMW,gBAAgB,GAAG;AACrB;AACAC,EAAAA,KAAK,EAAE;AAAA,QAAC;AAAEC,MAAAA;AAAF,KAAD;AAAA,QAAQ;AAAEC,MAAAA,WAAW,GAAG,GAAhB;AAAqBC,MAAAA,YAAY,GAAG;AAApC,KAAR;AAAA,WAAsDF,CAAC,CAACG,GAAF,GAAQH,CAAC,CAACI,GAAV,GAAgB/B,UAAU,CAAC4B,WAAD,CAA1B,GAA0C5B,UAAU,CAAC6B,YAAD,CAA1G;AAAA,GAFc;AAGrBG,EAAAA,MAAM,EAAE;AAAA,QAAC;AAAEC,MAAAA;AAAF,KAAD;AAAA,QAAQ;AAAEC,MAAAA,UAAU,GAAG,GAAf;AAAoBC,MAAAA,aAAa,GAAG;AAApC,KAAR;AAAA,WAAsDF,CAAC,CAACH,GAAF,GAAQG,CAAC,CAACF,GAAV,GAAgB/B,UAAU,CAACkC,UAAD,CAA1B,GAAyClC,UAAU,CAACmC,aAAD,CAAzG;AAAA,GAHa;AAIrBC,EAAAA,GAAG,EAAE,CAAC/B,KAAD;AAAA,QAAQ;AAAE+B,MAAAA;AAAF,KAAR;AAAA,WAAoBpC,UAAU,CAACoC,GAAD,CAA9B;AAAA,GAJgB;AAKrBC,EAAAA,IAAI,EAAE,CAAChC,KAAD;AAAA,QAAQ;AAAEgC,MAAAA;AAAF,KAAR;AAAA,WAAqBrC,UAAU,CAACqC,IAAD,CAA/B;AAAA,GALe;AAMrBC,EAAAA,MAAM,EAAE;AAAA,QAAC;AAAEL,MAAAA;AAAF,KAAD;AAAA,QAAQ;AAAEG,MAAAA;AAAF,KAAR;AAAA,WAAoBpC,UAAU,CAACoC,GAAD,CAAV,IAAmBH,CAAC,CAACH,GAAF,GAAQG,CAAC,CAACF,GAA7B,CAApB;AAAA,GANa;AAOrBQ,EAAAA,KAAK,EAAE;AAAA,QAAC;AAAEZ,MAAAA;AAAF,KAAD;AAAA,QAAQ;AAAEU,MAAAA;AAAF,KAAR;AAAA,WAAqBrC,UAAU,CAACqC,IAAD,CAAV,IAAoBV,CAAC,CAACG,GAAF,GAAQH,CAAC,CAACI,GAA9B,CAArB;AAAA,GAPc;AAQrB;AACAJ,EAAAA,CAAC,EAAEzB,sBAAsB,CAAC,CAAD,EAAI,EAAJ,CATJ;AAUrB+B,EAAAA,CAAC,EAAE/B,sBAAsB,CAAC,CAAD,EAAI,EAAJ;AAVJ,CAAzB;;AAYA,MAAMsC,wBAAwB,GAAG,CAACjD,MAAD,EAASsB,aAAT,EAAwB4B,WAAxB,KAAwC;AACrE,QAAMC,UAAU,GAAG7B,aAAa,CAAC8B,kBAAd,EAAnB;AACA,QAAMC,OAAO,GAAG/B,aAAa,CAACgC,OAA9B;AACA,QAAMC,oBAAoB,GAAGC,gBAAgB,CAACH,OAAD,CAA7C;AACA,QAAM;AAAEI,IAAAA;AAAF,MAAcF,oBAApB;AACA,QAAMG,MAAM,GAAG,EAAf,CALqE,CAMrE;AACA;;AACA,MAAID,OAAO,KAAK,MAAhB,EAAwB;AACpBnC,IAAAA,aAAa,CAACqC,cAAd,CAA6B,SAA7B,EAAwC3D,MAAM,CAACyD,OAAP,IAAkB,OAA1D;AACH;AACD;AACJ;AACA;;;AACIP,EAAAA,WAAW,CAAC1B,OAAZ,CAAqB3B,GAAD,IAAS;AACzB6D,IAAAA,MAAM,CAAC7D,GAAD,CAAN,GAAcqC,gBAAgB,CAACrC,GAAD,CAAhB,CAAsBsD,UAAtB,EAAkCI,oBAAlC,CAAd;AACH,GAFD,EAdqE,CAiBrE;;AACAjC,EAAAA,aAAa,CAACW,MAAd;AACA,QAAM2B,UAAU,GAAGtC,aAAa,CAAC8B,kBAAd,EAAnB;AACAF,EAAAA,WAAW,CAAC1B,OAAZ,CAAqB3B,GAAD,IAAS;AACzB;AACA;AACA,UAAM4B,KAAK,GAAGH,aAAa,CAACI,QAAd,CAAuB7B,GAAvB,CAAd;AACA4B,IAAAA,KAAK,IAAIA,KAAK,CAACoC,IAAN,CAAWH,MAAM,CAAC7D,GAAD,CAAjB,CAAT;AACAG,IAAAA,MAAM,CAACH,GAAD,CAAN,GAAcqC,gBAAgB,CAACrC,GAAD,CAAhB,CAAsB+D,UAAtB,EAAkCL,oBAAlC,CAAd;AACH,GAND;AAOA,SAAOvD,MAAP;AACH,CA5BD;;AA6BA,MAAM8D,gCAAgC,GAAG,UAACxC,aAAD,EAAgBtB,MAAhB,EAA4D;AAAA,MAApC0D,MAAoC,uEAA3B,EAA2B;AAAA,MAAvBK,aAAuB,uEAAP,EAAO;AACjG/D,EAAAA,MAAM,GAAG,EAAE,GAAGA;AAAL,GAAT;AACA+D,EAAAA,aAAa,GAAG,EAAE,GAAGA;AAAL,GAAhB;AACA,QAAMC,oBAAoB,GAAG/D,MAAM,CAACC,IAAP,CAAYF,MAAZ,EAAoBoB,MAApB,CAA2BxB,eAA3B,CAA7B,CAHiG,CAIjG;AACA;;AACA,MAAIqE,sBAAsB,GAAG,EAA7B;AACA,MAAIC,mCAAmC,GAAG,KAA1C;AACA,QAAMC,oBAAoB,GAAG,EAA7B;AACAH,EAAAA,oBAAoB,CAACxC,OAArB,CAA8B3B,GAAD,IAAS;AAClC,UAAM4B,KAAK,GAAGH,aAAa,CAACI,QAAd,CAAuB7B,GAAvB,CAAd;AACA,QAAI,CAACyB,aAAa,CAAC8C,QAAd,CAAuBvE,GAAvB,CAAL,EACI;AACJ,QAAIwE,IAAI,GAAGX,MAAM,CAAC7D,GAAD,CAAjB;AACA,QAAIyE,QAAQ,GAAGhF,sBAAsB,CAAC+E,IAAD,CAArC;AACA,UAAME,EAAE,GAAGvE,MAAM,CAACH,GAAD,CAAjB;AACA,QAAI2E,MAAJ,CAPkC,CAQlC;AACA;AACA;AACA;;AACA,QAAIrF,iBAAiB,CAACoF,EAAD,CAArB,EAA2B;AACvB,YAAME,YAAY,GAAGF,EAAE,CAACvC,MAAxB;AACA,YAAM0C,SAAS,GAAGH,EAAE,CAAC,CAAD,CAAF,KAAU,IAAV,GAAiB,CAAjB,GAAqB,CAAvC;AACAF,MAAAA,IAAI,GAAGE,EAAE,CAACG,SAAD,CAAT;AACAJ,MAAAA,QAAQ,GAAGhF,sBAAsB,CAAC+E,IAAD,CAAjC;;AACA,WAAK,IAAIM,CAAC,GAAGD,SAAb,EAAwBC,CAAC,GAAGF,YAA5B,EAA0CE,CAAC,EAA3C,EAA+C;AAC3C;AAChB;AACA;AACA;AACgB,YAAIJ,EAAE,CAACI,CAAD,CAAF,KAAU,IAAd,EACI;;AACJ,YAAI,CAACH,MAAL,EAAa;AACTA,UAAAA,MAAM,GAAGlF,sBAAsB,CAACiF,EAAE,CAACI,CAAD,CAAH,CAA/B;AACAvF,UAAAA,SAAS,CAACoF,MAAM,KAAKF,QAAX,IACLlE,aAAa,CAACkE,QAAD,CAAb,IAA2BlE,aAAa,CAACoE,MAAD,CADpC,EAC+C,8DAD/C,CAAT;AAEH,SAJD,MAKK;AACDpF,UAAAA,SAAS,CAACE,sBAAsB,CAACiF,EAAE,CAACI,CAAD,CAAH,CAAtB,KAAkCH,MAAnC,EAA2C,wCAA3C,CAAT;AACH;AACJ;AACJ,KArBD,MAsBK;AACDA,MAAAA,MAAM,GAAGlF,sBAAsB,CAACiF,EAAD,CAA/B;AACH;;AACD,QAAID,QAAQ,KAAKE,MAAjB,EAAyB;AACrB;AACA;AACA,UAAIpE,aAAa,CAACkE,QAAD,CAAb,IAA2BlE,aAAa,CAACoE,MAAD,CAA5C,EAAsD;AAClD,cAAMlB,OAAO,GAAG7B,KAAK,CAACI,GAAN,EAAhB;;AACA,YAAI,OAAOyB,OAAP,KAAmB,QAAvB,EAAiC;AAC7B7B,UAAAA,KAAK,CAACK,GAAN,CAAUrB,UAAU,CAAC6C,OAAD,CAApB;AACH;;AACD,YAAI,OAAOiB,EAAP,KAAc,QAAlB,EAA4B;AACxBvE,UAAAA,MAAM,CAACH,GAAD,CAAN,GAAcY,UAAU,CAAC8D,EAAD,CAAxB;AACH,SAFD,MAGK,IAAIK,KAAK,CAACC,OAAN,CAAcN,EAAd,KAAqBC,MAAM,KAAK/E,EAApC,EAAwC;AACzCO,UAAAA,MAAM,CAACH,GAAD,CAAN,GAAc0E,EAAE,CAACO,GAAH,CAAOrE,UAAP,CAAd;AACH;AACJ,OAXD,MAYK,IAAI,CAAC6D,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAACvD,SAA9D,MACJyD,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAACzD,SADnD,MAEJsD,IAAI,KAAK,CAAT,IAAcE,EAAE,KAAK,CAFjB,CAAJ,EAEyB;AAC1B;AACA;AACA,YAAIF,IAAI,KAAK,CAAb,EAAgB;AACZ5C,UAAAA,KAAK,CAACK,GAAN,CAAU0C,MAAM,CAACzD,SAAP,CAAiBsD,IAAjB,CAAV;AACH,SAFD,MAGK;AACDrE,UAAAA,MAAM,CAACH,GAAD,CAAN,GAAcyE,QAAQ,CAACvD,SAAT,CAAmBwD,EAAnB,CAAd;AACH;AACJ,OAXI,MAYA;AACD;AACA;AACA,YAAI,CAACL,mCAAL,EAA0C;AACtCD,UAAAA,sBAAsB,GAClB5C,+BAA+B,CAACC,aAAD,CADnC;AAEA4C,UAAAA,mCAAmC,GAAG,IAAtC;AACH;;AACDC,QAAAA,oBAAoB,CAACvC,IAArB,CAA0B/B,GAA1B;AACAkE,QAAAA,aAAa,CAAClE,GAAD,CAAb,GACIkE,aAAa,CAAClE,GAAD,CAAb,KAAuB8B,SAAvB,GACMoC,aAAa,CAAClE,GAAD,CADnB,GAEMG,MAAM,CAACH,GAAD,CAHhB;AAIA4B,QAAAA,KAAK,CAACoC,IAAN,CAAWU,EAAX;AACH;AACJ;AACJ,GAhFD;;AAiFA,MAAIJ,oBAAoB,CAACnC,MAAzB,EAAiC;AAC7B,UAAM+C,OAAO,GAAGZ,oBAAoB,CAACa,OAArB,CAA6B,QAA7B,KAA0C,CAA1C,GACVC,MAAM,CAACC,WADG,GAEV,IAFN;AAGA,UAAMC,eAAe,GAAGlC,wBAAwB,CAACjD,MAAD,EAASsB,aAAT,EAAwB6C,oBAAxB,CAAhD,CAJ6B,CAK7B;;AACA,QAAIF,sBAAsB,CAACjC,MAA3B,EAAmC;AAC/BiC,MAAAA,sBAAsB,CAACzC,OAAvB,CAA+B,UAAkB;AAAA,YAAjB,CAAC3B,GAAD,EAAM4B,KAAN,CAAiB;AAC7CH,QAAAA,aAAa,CAACI,QAAd,CAAuB7B,GAAvB,EAA4BiC,GAA5B,CAAgCL,KAAhC;AACH,OAFD;AAGH,KAV4B,CAW7B;;;AACAH,IAAAA,aAAa,CAACW,MAAd,GAZ6B,CAa7B;;AACA,QAAI1C,SAAS,IAAIwF,OAAO,KAAK,IAA7B,EAAmC;AAC/BE,MAAAA,MAAM,CAACG,QAAP,CAAgB;AAAEvC,QAAAA,GAAG,EAAEkC;AAAP,OAAhB;AACH;;AACD,WAAO;AAAE/E,MAAAA,MAAM,EAAEmF,eAAV;AAA2BpB,MAAAA;AAA3B,KAAP;AACH,GAlBD,MAmBK;AACD,WAAO;AAAE/D,MAAAA,MAAF;AAAU+D,MAAAA;AAAV,KAAP;AACH;AACJ,CAhHD;AAiHA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASsB,cAAT,CAAwB/D,aAAxB,EAAuCtB,MAAvC,EAA+C0D,MAA/C,EAAuDK,aAAvD,EAAsE;AAClE,SAAOhE,gBAAgB,CAACC,MAAD,CAAhB,GACD8D,gCAAgC,CAACxC,aAAD,EAAgBtB,MAAhB,EAAwB0D,MAAxB,EAAgCK,aAAhC,CAD/B,GAED;AAAE/D,IAAAA,MAAF;AAAU+D,IAAAA;AAAV,GAFN;AAGH;;AAED,SAAS7B,gBAAT,EAA2BmD,cAA3B","sourcesContent":["import { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.mjs';\nimport { invariant } from '../../../utils/errors.mjs';\nimport { transformPropOrder } from '../../html/utils/transform.mjs';\nimport { findDimensionValueType } from '../value-types/dimensions.mjs';\nimport { isBrowser } from '../../../utils/is-browser.mjs';\nimport { number } from '../../../value/types/numbers/index.mjs';\nimport { px } from '../../../value/types/numbers/units.mjs';\n\nconst positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\",\n    \"translateX\",\n    \"translateY\",\n]);\nconst isPositionalKey = (key) => positionalKeys.has(key);\nconst hasPositionalKey = (target) => {\n    return Object.keys(target).some(isPositionalKey);\n};\nconst isNumOrPxType = (v) => v === number || v === px;\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\n    if (transform === \"none\" || !transform)\n        return 0;\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        const matrix = transform.match(/^matrix\\((.+)\\)$/);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n};\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length)\n        visualElement.render();\n    return removedTransforms;\n}\nconst positionalValues = {\n    // Dimensions\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n    top: (_bbox, { top }) => parseFloat(top),\n    left: (_bbox, { left }) => parseFloat(left),\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\nconst convertChangedValueTypes = (target, visualElement, changedKeys) => {\n    const originBbox = visualElement.measureViewportBox();\n    const element = visualElement.current;\n    const elementComputedStyle = getComputedStyle(element);\n    const { display } = elementComputedStyle;\n    const origin = {};\n    // If the element is currently set to display: \"none\", make it visible before\n    // measuring the target bounding box\n    if (display === \"none\") {\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\n    }\n    /**\n     * Record origins before we render and update styles\n     */\n    changedKeys.forEach((key) => {\n        origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n    });\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.render();\n    const targetBbox = visualElement.measureViewportBox();\n    changedKeys.forEach((key) => {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        const value = visualElement.getValue(key);\n        value && value.jump(origin[key]);\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nconst checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {\n    target = { ...target };\n    transitionEnd = { ...transitionEnd };\n    const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element's bounding box before\n    // it's measured. We'll reapply these later.\n    let removedTransformValues = [];\n    let hasAttemptedToRemoveTransformValues = false;\n    const changedValueTypeKeys = [];\n    targetPositionalKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key))\n            return;\n        let from = origin[key];\n        let fromType = findDimensionValueType(from);\n        const to = target[key];\n        let toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There's probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it'd be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            const numKeyframes = to.length;\n            const fromIndex = to[0] === null ? 1 : 0;\n            from = to[fromIndex];\n            fromType = findDimensionValueType(from);\n            for (let i = fromIndex; i < numKeyframes; i++) {\n                /**\n                 * Don't allow wildcard keyframes to be used to detect\n                 * a difference in value types.\n                 */\n                if (to[i] === null)\n                    break;\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    invariant(toType === fromType ||\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\n                }\n                else {\n                    invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n                }\n            }\n        }\n        else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they're both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                const current = value.get();\n                if (typeof current === \"string\") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === \"string\") {\n                    target[key] = parseFloat(to);\n                }\n                else if (Array.isArray(to) && toType === px) {\n                    target[key] = to.map(parseFloat);\n                }\n            }\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\n                (from === 0 || to === 0)) {\n                // If one or the other value is 0, it's safe to coerce it to the\n                // type of the other without measurement\n                if (from === 0) {\n                    value.set(toType.transform(from));\n                }\n                else {\n                    target[key] = fromType.transform(to);\n                }\n            }\n            else {\n                // If we're going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues =\n                        removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] =\n                    transitionEnd[key] !== undefined\n                        ? transitionEnd[key]\n                        : target[key];\n                value.jump(to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0\n            ? window.pageYOffset\n            : null;\n        const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(([key, value]) => {\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.render();\n        // Restore scroll position\n        if (isBrowser && scrollY !== null) {\n            window.scrollTo({ top: scrollY });\n        }\n        return { target: convertedTarget, transitionEnd };\n    }\n    else {\n        return { target, transitionEnd };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target)\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\n        : { target, transitionEnd };\n}\n\nexport { positionalValues, unitConversion };\n"]},"metadata":{},"sourceType":"module"}