{"ast":null,"code":"import { warning } from '../../utils/errors.mjs';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { createAcceleratedAnimation } from '../animators/waapi/create-accelerated-animation.mjs';\nimport { createInstantAnimation } from '../animators/instant.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { isAnimatable } from '../utils/is-animatable.mjs';\nimport { getKeyframes } from '../utils/keyframes.mjs';\nimport { getValueTransition, isTransitionDefined } from '../utils/transitions.mjs';\nimport { animateValue } from '../animators/js/index.mjs';\n\nconst animateMotionValue = function (valueName, value, target) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return onComplete => {\n    const valueTransition = getValueTransition(transition, valueName) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n\n    let {\n      elapsed = 0\n    } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    const keyframes = getKeyframes(value, valueName, target, valueTransition);\n    /**\n     * Check if we're able to animate between the start and end keyframes,\n     * and throw a warning if we're attempting to animate between one that's\n     * animatable and another that isn't.\n     */\n\n    const originKeyframe = keyframes[0];\n    const targetKeyframe = keyframes[keyframes.length - 1];\n    const isOriginAnimatable = isAnimatable(valueName, originKeyframe);\n    const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n    let options = {\n      keyframes,\n      velocity: value.getVelocity(),\n      ease: \"easeOut\",\n      ...valueTransition,\n      delay: -elapsed,\n      onUpdate: v => {\n        value.set(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: () => {\n        onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n      }\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n\n    if (!isTransitionDefined(valueTransition)) {\n      options = { ...options,\n        ...getDefaultTransition(valueName, options)\n      };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n\n\n    if (options.duration) {\n      options.duration = secondsToMilliseconds(options.duration);\n    }\n\n    if (options.repeatDelay) {\n      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n\n    if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false) {\n      /**\n       * If we can't animate this value, or the global instant animation flag is set,\n       * or this is simply defined as an instant transition, return an instant transition.\n       */\n      return createInstantAnimation(options);\n    }\n    /**\n     * Animate via WAAPI if possible.\n     */\n\n\n    if (value.owner && value.owner.current instanceof HTMLElement && !value.owner.getProps().onUpdate) {\n      const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);\n      if (acceleratedAnimation) return acceleratedAnimation;\n    }\n    /**\n     * If we didn't create an accelerated animation, create a JS animation\n     */\n\n\n    return animateValue(options);\n  };\n};\n\nexport { animateMotionValue };","map":{"version":3,"sources":["C:/Users/91800/Desktop/Personal-Portfolio-React-master/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs"],"names":["warning","secondsToMilliseconds","instantAnimationState","createAcceleratedAnimation","createInstantAnimation","getDefaultTransition","isAnimatable","getKeyframes","getValueTransition","isTransitionDefined","animateValue","animateMotionValue","valueName","value","target","transition","onComplete","valueTransition","delay","elapsed","keyframes","originKeyframe","targetKeyframe","length","isOriginAnimatable","isTargetAnimatable","options","velocity","getVelocity","ease","onUpdate","v","set","duration","repeatDelay","current","type","owner","HTMLElement","getProps","acceleratedAnimation"],"mappings":"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","sourcesContent":["import { warning } from '../../utils/errors.mjs';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { createAcceleratedAnimation } from '../animators/waapi/create-accelerated-animation.mjs';\nimport { createInstantAnimation } from '../animators/instant.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { isAnimatable } from '../utils/is-animatable.mjs';\nimport { getKeyframes } from '../utils/keyframes.mjs';\nimport { getValueTransition, isTransitionDefined } from '../utils/transitions.mjs';\nimport { animateValue } from '../animators/js/index.mjs';\n\nconst animateMotionValue = (valueName, value, target, transition = {}) => {\n    return (onComplete) => {\n        const valueTransition = getValueTransition(transition, valueName) || {};\n        /**\n         * Most transition values are currently completely overwritten by value-specific\n         * transitions. In the future it'd be nicer to blend these transitions. But for now\n         * delay actually does inherit from the root transition if not value-specific.\n         */\n        const delay = valueTransition.delay || transition.delay || 0;\n        /**\n         * Elapsed isn't a public transition option but can be passed through from\n         * optimized appear effects in milliseconds.\n         */\n        let { elapsed = 0 } = transition;\n        elapsed = elapsed - secondsToMilliseconds(delay);\n        const keyframes = getKeyframes(value, valueName, target, valueTransition);\n        /**\n         * Check if we're able to animate between the start and end keyframes,\n         * and throw a warning if we're attempting to animate between one that's\n         * animatable and another that isn't.\n         */\n        const originKeyframe = keyframes[0];\n        const targetKeyframe = keyframes[keyframes.length - 1];\n        const isOriginAnimatable = isAnimatable(valueName, originKeyframe);\n        const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);\n        warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n        let options = {\n            keyframes,\n            velocity: value.getVelocity(),\n            ease: \"easeOut\",\n            ...valueTransition,\n            delay: -elapsed,\n            onUpdate: (v) => {\n                value.set(v);\n                valueTransition.onUpdate && valueTransition.onUpdate(v);\n            },\n            onComplete: () => {\n                onComplete();\n                valueTransition.onComplete && valueTransition.onComplete();\n            },\n        };\n        /**\n         * If there's no transition defined for this value, we can generate\n         * unqiue transition settings for this value.\n         */\n        if (!isTransitionDefined(valueTransition)) {\n            options = {\n                ...options,\n                ...getDefaultTransition(valueName, options),\n            };\n        }\n        /**\n         * Both WAAPI and our internal animation functions use durations\n         * as defined by milliseconds, while our external API defines them\n         * as seconds.\n         */\n        if (options.duration) {\n            options.duration = secondsToMilliseconds(options.duration);\n        }\n        if (options.repeatDelay) {\n            options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n        }\n        if (!isOriginAnimatable ||\n            !isTargetAnimatable ||\n            instantAnimationState.current ||\n            valueTransition.type === false) {\n            /**\n             * If we can't animate this value, or the global instant animation flag is set,\n             * or this is simply defined as an instant transition, return an instant transition.\n             */\n            return createInstantAnimation(options);\n        }\n        /**\n         * Animate via WAAPI if possible.\n         */\n        if (value.owner &&\n            value.owner.current instanceof HTMLElement &&\n            !value.owner.getProps().onUpdate) {\n            const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);\n            if (acceleratedAnimation)\n                return acceleratedAnimation;\n        }\n        /**\n         * If we didn't create an accelerated animation, create a JS animation\n         */\n        return animateValue(options);\n    };\n};\n\nexport { animateMotionValue };\n"]},"metadata":{},"sourceType":"module"}