{"ast":null,"code":"import { mix } from './mix.mjs';\nimport { mixColor } from './mix-color.mjs';\nimport { pipe } from './pipe.mjs';\nimport { warning } from './errors.mjs';\nimport { color } from '../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../value/types/complex/index.mjs';\n\nconst mixImmediate = (origin, target) => p => `${p > 0 ? target : origin}`;\n\nfunction getMixer(origin, target) {\n  if (typeof origin === \"number\") {\n    return v => mix(origin, target, v);\n  } else if (color.test(origin)) {\n    return mixColor(origin, target);\n  } else {\n    return origin.startsWith(\"var(\") ? mixImmediate(origin, target) : mixComplex(origin, target);\n  }\n}\n\nconst mixArray = (from, to) => {\n  const output = [...from];\n  const numValues = output.length;\n  const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));\n  return v => {\n    for (let i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](v);\n    }\n\n    return output;\n  };\n};\n\nconst mixObject = (origin, target) => {\n  const output = { ...origin,\n    ...target\n  };\n  const blendValue = {};\n\n  for (const key in output) {\n    if (origin[key] !== undefined && target[key] !== undefined) {\n      blendValue[key] = getMixer(origin[key], target[key]);\n    }\n  }\n\n  return v => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n\n    return output;\n  };\n};\n\nconst mixComplex = (origin, target) => {\n  const template = complex.createTransformer(target);\n  const originStats = analyseComplexValue(origin);\n  const targetStats = analyseComplexValue(target);\n  const canInterpolate = originStats.numVars === targetStats.numVars && originStats.numColors === targetStats.numColors && originStats.numNumbers >= targetStats.numNumbers;\n\n  if (canInterpolate) {\n    return pipe(mixArray(originStats.values, targetStats.values), template);\n  } else {\n    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n    return mixImmediate(origin, target);\n  }\n};\n\nexport { mixArray, mixComplex, mixObject };","map":{"version":3,"sources":["C:/Users/91800/Desktop/Personal-Portfolio-React-master/node_modules/framer-motion/dist/es/utils/mix-complex.mjs"],"names":["mix","mixColor","pipe","warning","color","complex","analyseComplexValue","mixImmediate","origin","target","p","getMixer","v","test","startsWith","mixComplex","mixArray","from","to","output","numValues","length","blendValue","map","fromThis","i","mixObject","key","undefined","template","createTransformer","originStats","targetStats","canInterpolate","numVars","numColors","numNumbers","values"],"mappings":"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","sourcesContent":["import { mix } from './mix.mjs';\nimport { mixColor } from './mix-color.mjs';\nimport { pipe } from './pipe.mjs';\nimport { warning } from './errors.mjs';\nimport { color } from '../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../value/types/complex/index.mjs';\n\nconst mixImmediate = (origin, target) => (p) => `${p > 0 ? target : origin}`;\nfunction getMixer(origin, target) {\n    if (typeof origin === \"number\") {\n        return (v) => mix(origin, target, v);\n    }\n    else if (color.test(origin)) {\n        return mixColor(origin, target);\n    }\n    else {\n        return origin.startsWith(\"var(\")\n            ? mixImmediate(origin, target)\n            : mixComplex(origin, target);\n    }\n}\nconst mixArray = (from, to) => {\n    const output = [...from];\n    const numValues = output.length;\n    const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));\n    return (v) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](v);\n        }\n        return output;\n    };\n};\nconst mixObject = (origin, target) => {\n    const output = { ...origin, ...target };\n    const blendValue = {};\n    for (const key in output) {\n        if (origin[key] !== undefined && target[key] !== undefined) {\n            blendValue[key] = getMixer(origin[key], target[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n};\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.numVars === targetStats.numVars &&\n        originStats.numColors === targetStats.numColors &&\n        originStats.numNumbers >= targetStats.numNumbers;\n    if (canInterpolate) {\n        return pipe(mixArray(originStats.values, targetStats.values), template);\n    }\n    else {\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return mixImmediate(origin, target);\n    }\n};\n\nexport { mixArray, mixComplex, mixObject };\n"]},"metadata":{},"sourceType":"module"}