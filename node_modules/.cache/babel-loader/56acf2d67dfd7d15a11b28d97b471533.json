{"ast":null,"code":"function createRenderStep(runNextFrame) {\n  /**\n   * We create and reuse two arrays, one to queue jobs for the current frame\n   * and one for the next. We reuse to avoid triggering GC after x frames.\n   */\n  let toRun = [];\n  let toRunNextFrame = [];\n  /**\n   *\n   */\n\n  let numToRun = 0;\n  /**\n   * Track whether we're currently processing jobs in this step. This way\n   * we can decide whether to schedule new jobs for this frame or next.\n   */\n\n  let isProcessing = false;\n  let flushNextFrame = false;\n  /**\n   * A set of processes which were marked keepAlive when scheduled.\n   */\n\n  const toKeepAlive = new WeakSet();\n  const step = {\n    /**\n     * Schedule a process to run on the next frame.\n     */\n    schedule: function (callback) {\n      let keepAlive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      let immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      const addToCurrentFrame = immediate && isProcessing;\n      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n      if (keepAlive) toKeepAlive.add(callback); // If the buffer doesn't already contain this callback, add it\n\n      if (buffer.indexOf(callback) === -1) {\n        buffer.push(callback); // If we're adding it to the currently running buffer, update its measured size\n\n        if (addToCurrentFrame && isProcessing) numToRun = toRun.length;\n      }\n\n      return callback;\n    },\n\n    /**\n     * Cancel the provided callback from running on the next frame.\n     */\n    cancel: callback => {\n      const index = toRunNextFrame.indexOf(callback);\n      if (index !== -1) toRunNextFrame.splice(index, 1);\n      toKeepAlive.delete(callback);\n    },\n\n    /**\n     * Execute all schedule callbacks.\n     */\n    process: frameData => {\n      /**\n       * If we're already processing we've probably been triggered by a flushSync\n       * inside an existing process. Instead of executing, mark flushNextFrame\n       * as true and ensure we flush the following frame at the end of this one.\n       */\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n\n      isProcessing = true;\n      [toRun, toRunNextFrame] = [toRunNextFrame, toRun]; // Clear the next frame list\n\n      toRunNextFrame.length = 0; // Execute this frame\n\n      numToRun = toRun.length;\n\n      if (numToRun) {\n        for (let i = 0; i < numToRun; i++) {\n          const callback = toRun[i];\n          callback(frameData);\n\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n          }\n        }\n      }\n\n      isProcessing = false;\n\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\n\nexport { createRenderStep };","map":{"version":3,"sources":["C:/Users/91800/Desktop/Personal-Portfolio-React-master/node_modules/framer-motion/dist/es/frameloop/create-render-step.mjs"],"names":["createRenderStep","runNextFrame","toRun","toRunNextFrame","numToRun","isProcessing","flushNextFrame","toKeepAlive","WeakSet","step","schedule","callback","keepAlive","immediate","addToCurrentFrame","buffer","add","indexOf","push","length","cancel","index","splice","delete","process","frameData","i","has"],"mappings":"AAAA,SAASA,gBAAT,CAA0BC,YAA1B,EAAwC;AACpC;AACJ;AACA;AACA;AACI,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,cAAc,GAAG,EAArB;AACA;AACJ;AACA;;AACI,MAAIC,QAAQ,GAAG,CAAf;AACA;AACJ;AACA;AACA;;AACI,MAAIC,YAAY,GAAG,KAAnB;AACA,MAAIC,cAAc,GAAG,KAArB;AACA;AACJ;AACA;;AACI,QAAMC,WAAW,GAAG,IAAIC,OAAJ,EAApB;AACA,QAAMC,IAAI,GAAG;AACT;AACR;AACA;AACQC,IAAAA,QAAQ,EAAE,UAACC,QAAD,EAAoD;AAAA,UAAzCC,SAAyC,uEAA7B,KAA6B;AAAA,UAAtBC,SAAsB,uEAAV,KAAU;AAC1D,YAAMC,iBAAiB,GAAGD,SAAS,IAAIR,YAAvC;AACA,YAAMU,MAAM,GAAGD,iBAAiB,GAAGZ,KAAH,GAAWC,cAA3C;AACA,UAAIS,SAAJ,EACIL,WAAW,CAACS,GAAZ,CAAgBL,QAAhB,EAJsD,CAK1D;;AACA,UAAII,MAAM,CAACE,OAAP,CAAeN,QAAf,MAA6B,CAAC,CAAlC,EAAqC;AACjCI,QAAAA,MAAM,CAACG,IAAP,CAAYP,QAAZ,EADiC,CAEjC;;AACA,YAAIG,iBAAiB,IAAIT,YAAzB,EACID,QAAQ,GAAGF,KAAK,CAACiB,MAAjB;AACP;;AACD,aAAOR,QAAP;AACH,KAjBQ;;AAkBT;AACR;AACA;AACQS,IAAAA,MAAM,EAAGT,QAAD,IAAc;AAClB,YAAMU,KAAK,GAAGlB,cAAc,CAACc,OAAf,CAAuBN,QAAvB,CAAd;AACA,UAAIU,KAAK,KAAK,CAAC,CAAf,EACIlB,cAAc,CAACmB,MAAf,CAAsBD,KAAtB,EAA6B,CAA7B;AACJd,MAAAA,WAAW,CAACgB,MAAZ,CAAmBZ,QAAnB;AACH,KA1BQ;;AA2BT;AACR;AACA;AACQa,IAAAA,OAAO,EAAGC,SAAD,IAAe;AACpB;AACZ;AACA;AACA;AACA;AACY,UAAIpB,YAAJ,EAAkB;AACdC,QAAAA,cAAc,GAAG,IAAjB;AACA;AACH;;AACDD,MAAAA,YAAY,GAAG,IAAf;AACA,OAACH,KAAD,EAAQC,cAAR,IAA0B,CAACA,cAAD,EAAiBD,KAAjB,CAA1B,CAXoB,CAYpB;;AACAC,MAAAA,cAAc,CAACgB,MAAf,GAAwB,CAAxB,CAboB,CAcpB;;AACAf,MAAAA,QAAQ,GAAGF,KAAK,CAACiB,MAAjB;;AACA,UAAIf,QAAJ,EAAc;AACV,aAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtB,QAApB,EAA8BsB,CAAC,EAA/B,EAAmC;AAC/B,gBAAMf,QAAQ,GAAGT,KAAK,CAACwB,CAAD,CAAtB;AACAf,UAAAA,QAAQ,CAACc,SAAD,CAAR;;AACA,cAAIlB,WAAW,CAACoB,GAAZ,CAAgBhB,QAAhB,CAAJ,EAA+B;AAC3BF,YAAAA,IAAI,CAACC,QAAL,CAAcC,QAAd;AACAV,YAAAA,YAAY;AACf;AACJ;AACJ;;AACDI,MAAAA,YAAY,GAAG,KAAf;;AACA,UAAIC,cAAJ,EAAoB;AAChBA,QAAAA,cAAc,GAAG,KAAjB;AACAG,QAAAA,IAAI,CAACe,OAAL,CAAaC,SAAb;AACH;AACJ;AA7DQ,GAAb;AA+DA,SAAOhB,IAAP;AACH;;AAED,SAAST,gBAAT","sourcesContent":["function createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two arrays, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let toRun = [];\n    let toRunNextFrame = [];\n    /**\n     *\n     */\n    let numToRun = 0;\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            // If the buffer doesn't already contain this callback, add it\n            if (buffer.indexOf(callback) === -1) {\n                buffer.push(callback);\n                // If we're adding it to the currently running buffer, update its measured size\n                if (addToCurrentFrame && isProcessing)\n                    numToRun = toRun.length;\n            }\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            const index = toRunNextFrame.indexOf(callback);\n            if (index !== -1)\n                toRunNextFrame.splice(index, 1);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [toRun, toRunNextFrame] = [toRunNextFrame, toRun];\n            // Clear the next frame list\n            toRunNextFrame.length = 0;\n            // Execute this frame\n            numToRun = toRun.length;\n            if (numToRun) {\n                for (let i = 0; i < numToRun; i++) {\n                    const callback = toRun[i];\n                    callback(frameData);\n                    if (toKeepAlive.has(callback)) {\n                        step.schedule(callback);\n                        runNextFrame();\n                    }\n                }\n            }\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n"]},"metadata":{},"sourceType":"module"}